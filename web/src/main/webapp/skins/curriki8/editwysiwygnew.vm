#set($formname = "edit")
#set($saveaction = "save")
#set($previewenabled = true)
#set($xredirect=$!request.getParameter("xredirect"))
## <form id="edit" method="post" action="$doc.getURL("preview")">
## #set($editactions = "top")
## <div class="topbuttons">#template("editactions.vm")</div>
<div>
<div class="hidden">
<input type="hidden" name="template" value="$!request.template" />
#if($request.section && $request.section!="")
 #set($xcontinue=$doc.getURL("edit", "editor=wysiwyg&section=$request.section"))
#else
 #set($xcontinue=$doc.getURL("edit", "editor=wysiwyg"))
#end
<input type="hidden" name="xcontinue" value="$xcontinue"/>
<input type="hidden" name="xredirect" value="$!xredirect" />
<input type="hidden" name="language" value="$!tdoc.realLanguage" />
## <input type="hidden" id="xwikidoctitleinput" name="title" value="$!tdoc.title"/>
## <input type="hidden" id="xwikidocparentinput" name="parent" value="$!tdoc.parent"/>
</div>
<div id="xwikitext">
<div id="xwikieditcontent">
#if($xwiki.wysiwyg.isSyntaxSupported($doc.syntaxId))
##
## We should find a better way of including the JavaScript code of the editor!
##
<script type="text/javascript" src="$xwiki.getSkinFile("js/xwiki/wysiwyg/gwt/com.xpn.xwiki.wysiwyg.Wysiwyg/com.xpn.xwiki.wysiwyg.Wysiwyg.nocache.js")"></script>
##
## Get the WYSIWYG input map in order to add the the data for this request.
## This map is needed to keep user changes while switching editors and after server-side exceptions.
##
#set($wysiwygInput = $request.getSession().getAttribute("com.xpn.xwiki.wysiwyg.input"))
#if(!$wysiwygInput)
#set($wysiwygInput = $util.getHashMap())
$request.getSession().setAttribute("com.xpn.xwiki.wysiwyg.input", $wysiwygInput)
#end
##
## Determine the key into the WYSIWYG input and error map.
## We pass this key to the WYSIWYG editor in the query string of the input URL.
## This key will be used in wysiwyginput.vm to get the content of the editor from the WYSIWYG input map.
##
#set($reuseKey = $request.keys && $wysiwygInput.containsKey($request.keys))
#if(!$request.sync && $reuseKey)
## If this template is called after a conversion exception then the content is already 
## stored in the input map. We have to use the key provided by the ConversionFilter.
#set($wysiwygKey = $request.keys)
#else
#set($wysiwygKey = $util.generateRandomString(4))
#end
##
## Determine the query string of the input URL.
## We pass the following arguments to the wysiwyginput.vm template:
## * key: the key in the WYSIWYG input map.
## * render: flag indicating if the content associated with the given key should be rendered or not.
##
#set($inputURLQueryString = "xpage=wysiwyginput&key=${wysiwygKey}")
#if(!($request.sync || $reuseKey))
#set($inputURLQueryString = $inputURLQueryString + "&render")
#end
##
## Determine the initial content of the editor.
## We can't use $tdoc.content when the user switches editors or when we encounter 
## a conversion exception because we would loose unsaved changes.
##
#if($request.sync)
#set($ok = $wysiwygInput.put($wysiwygKey, ""))
#elseif(!$reuseKey)
#set($ok = $wysiwygInput.put($wysiwygKey, $tdoc.content))
#end
##
## Get the WYSIWYG error map in order to display the conversion exceptions.
##
#set($wysiwygError = $request.getSession().getAttribute("com.xpn.xwiki.wysiwyg.error"))
#if($wysiwygError)
#set($error = $wysiwygError.get($wysiwygKey))
#if($error)
#error($error.message)
#set($ok = $wysiwygError.remove($wysiwygKey))
#end
#end
##
## The editor will replace the following text area with its own widget.
## If JavaScript is disabled the user will still be able to edit the document using this HTML text area.
##
$xwiki.getTextArea($tdoc.content)
##
## Configure the WYSIWYG editor.
##
<script type="text/javascript">
//<![CDATA[
    // Global configuration.
    var Wysiwyg = {
      xwikiservice: '${request.contextPath}/XWikiService',
      wysiwygServiceURL: '${request.contextPath}/WysiwygService'
    };
    // Instance configuration.
    var Wysiwyg0 = {
      hookId: 'content',
      inputURL: "${tdoc.getExternalURL("view", $inputURLQueryString)}",
#if($request.sync)
      syncPage: '$doc.fullName',
      plugins: 'separator text valign list indent undo format symbol link image table macro importer font color justify sync',
 #if($request.reset=="1")
      syncReset: 1,
 #end
#else
      plugins: 'separator text valign list indent undo format symbol link image table macro importer font color justify',
#end 
      syntax: "$doc.syntaxId",
      toolbar: 'bold italic underline strikethrough | subscript superscript | justifyleft justifycenter justifyright justifyfull | forecolor backcolor fontname fontsize |  unorderedlist orderedlist | outdent indent | undo redo | format | hr symbol | link unlink | importer | image | inserttable deletetable | insertrowbefore insertrowafter deleterow | insertcolbefore insertcolafter deletecol',
      space: '${doc.space}',
      page: '${doc.name}',
      debug: #if($request.debug)'true'#else'false'#end
    };
//]]>
</script>
#else
#warning("The new GWT-based WYSIWYG editor doesn't support the syntax of the current document: <em>$doc.syntaxId</em>.")
#end
</div>
</div>
</div>
#set($editactions = "bottom")
<div class="bottombuttons">#template("editactions.vm")</div>
## </form>
